package secret_test

import (
	"bytes"
	"context"
	"strings"
	"testing"
	"time"

	"github.com/fernet/fernet-go"
	"github.com/stretchr/testify/require"
	"k8s.io/apimachinery/pkg/types"

	"github.com/imdario/mergo"
	"github.com/mittwald/kubernetes-secret-generator/pkg/controller/secret"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

const (
	// fernetKeyLength is the length of a fernet key in bytes
	fernetKeyLength = 32
)

func newFernetTestSecret(fields string, extraAnnotations map[string]string, initValues string) *corev1.Secret {
	annotations := map[string]string{
		secret.AnnotationSecretAutoGenerate: fields,
		secret.AnnotationSecretType:         string(secret.TypeFernet),
	}
	if extraAnnotations != nil {
		if err := mergo.Merge(&annotations, extraAnnotations, mergo.WithOverride); err != nil {
			panic(err)
		}
	}

	s := &corev1.Secret{
		ObjectMeta: metav1.ObjectMeta{
			Name:      getSecretName(),
			Namespace: "default",
			Labels: map[string]string{
				labelSecretGeneratorTest: "yes",
			},
			Annotations: annotations,
		},
		Type: corev1.SecretTypeOpaque,
		Data: map[string][]byte{},
	}

	keys := strings.Split(fields, ",")
	for i, init := range strings.Split(initValues, ",") {
		s.Data[keys[i]] = []byte(init)
	}

	return s
}

// verify basic fields of the secret are present
func verifyFernetSecret(t *testing.T, in, out *corev1.Secret) {
	if out.Annotations[secret.AnnotationSecretType] != string(secret.TypeFernet) {
		t.Errorf("generated secret has wrong type %s on  %s annotation", out.Annotations[secret.AnnotationSecretType], secret.AnnotationSecretType)
	}

	_, wasGenerated := in.Annotations[secret.AnnotationSecretAutoGeneratedAt]

	for _, key := range strings.Split(in.Annotations[secret.AnnotationSecretAutoGenerate], ",") {
		val, ok := out.Data[key]
		if !ok {
			t.Error("secret value has not been generated")
		}

		// check if key has correct length (if the secret has actually been generated)
		fernetKey, err := fernet.DecodeKey(string(val))
		if err != nil {
			t.Error(err)
		}
		if !wasGenerated && (len(val) == 0 || len(fernetKey) != fernetKeyLength) {
			t.Errorf("generated key has wrong length of %d", len(fernetKey))
		}

		t.Logf("generated secret value: %s", val)
	}

	if _, ok := out.Annotations[secret.AnnotationSecretAutoGeneratedAt]; !ok {
		t.Errorf("secret has no %s annotation", secret.AnnotationSecretAutoGeneratedAt)
	}
}

// verify requested keys have been regenerated
func verifyFernetRegen(t *testing.T, in, out *corev1.Secret) {
	if _, ok := out.Annotations[secret.AnnotationSecretRegenerate]; ok {
		t.Errorf("%s annotation is still present", secret.AnnotationSecretRegenerate)
	}

	if _, ok := in.Annotations[secret.AnnotationSecretRegenerate]; !ok && !secret.RegenerateInsecure() { // test the tester
		t.Errorf("%s annotation is not present on input", secret.AnnotationSecretRegenerate)
	}

	if _, ok := in.Annotations[secret.AnnotationSecretAutoGeneratedAt]; !ok { // test the tester
		t.Errorf("%s annotation is not present on input", secret.AnnotationSecretAutoGeneratedAt)
	}

	var regenKeys []string
	if in.Annotations[secret.AnnotationSecretRegenerate] == "yes" {
		regenKeys = strings.Split(in.Annotations[secret.AnnotationSecretAutoGenerate], ",")
	} else if in.Annotations[secret.AnnotationSecretRegenerate] != "" {
		regenKeys = strings.Split(in.Annotations[secret.AnnotationSecretRegenerate], ",")
	}

	t.Logf("checking regenerated keys are regenerated and have correct length")
	t.Logf("keys expected to be regenerated: %d", len(regenKeys))
	if len(regenKeys) != 0 {
		for _, key := range regenKeys {
			val := out.Data[key]
			fernetKey, err := fernet.DecodeKey(string(val))
			if err != nil {
				t.Error(err)
			}
			if len(val) == 0 || len(fernetKey) != fernetKeyLength {
				t.Errorf("regenerated key has wrong length of %d", len(fernetKey))
			}
			if bytes.Equal(in.Data[key], val) {
				t.Errorf("key %s is equal for in(%s) and out (%s)", key, in.Data[key], out.Data[key])
				continue
			}
			t.Logf("key %s is NOT equal for in(%s) and out (%s)", key, in.Data[key], out.Data[key])
		}
	}

	t.Logf("checking generated keys are not regenerated")
	genKeys := strings.Split(in.Annotations[secret.AnnotationSecretAutoGenerate], ",")
	for _, key := range genKeys {
		if stringInSlice(key, regenKeys) {
			continue
		}
		if bytes.Equal(in.Data[key], out.Data[key]) {
			t.Logf("key %s is equal for in(%s) and out (%s)", key, in.Data[key], out.Data[key])
			continue
		}
		t.Errorf("key %s is NOT equal for in(%s) and out (%s)", key, in.Data[key], out.Data[key])
	}
}

func TestGenerateSecretSingleFernetField(t *testing.T) {
	in := newFernetTestSecret("testfield", nil, "")
	require.NoError(t, mgr.GetClient().Create(context.TODO(), in))

	doReconcile(t, in, false)

	out := &corev1.Secret{}
	require.NoError(t, mgr.GetClient().Get(context.TODO(), types.NamespacedName{
		Name:      in.Name,
		Namespace: in.Namespace}, out))

	verifyFernetSecret(t, in, out)
}

func TestGenerateSecretMultipleFernetFields(t *testing.T) {
	in := newFernetTestSecret("testfield,test1,test2,test3,abc,12345,6789", nil, "")
	require.NoError(t, mgr.GetClient().Create(context.TODO(), in))

	doReconcile(t, in, false)

	out := &corev1.Secret{}
	require.NoError(t, mgr.GetClient().Get(context.TODO(), types.NamespacedName{
		Name:      in.Name,
		Namespace: in.Namespace}, out))

	verifyFernetSecret(t, in, out)
}

func TestRegenerateSingleFernetField(t *testing.T) {
	in := newFernetTestSecret("testfield", map[string]string{
		secret.AnnotationSecretRegenerate:      "testfield",
		secret.AnnotationSecretAutoGeneratedAt: time.Now().Format(time.RFC3339),
	}, "test")
	require.NoError(t, mgr.GetClient().Create(context.TODO(), in))

	doReconcile(t, in, false)

	out := &corev1.Secret{}
	require.NoError(t, mgr.GetClient().Get(context.TODO(), types.NamespacedName{
		Name:      in.Name,
		Namespace: in.Namespace}, out))

	verifyFernetSecret(t, in, out)
	verifyFernetRegen(t, in, out)
}

func TestRegenerateAllSingleFernetField(t *testing.T) {
	in := newFernetTestSecret("testfield", map[string]string{
		secret.AnnotationSecretRegenerate:      "yes",
		secret.AnnotationSecretAutoGeneratedAt: time.Now().Format(time.RFC3339),
	}, "test")
	require.NoError(t, mgr.GetClient().Create(context.TODO(), in))

	doReconcile(t, in, false)

	out := &corev1.Secret{}
	require.NoError(t, mgr.GetClient().Get(context.TODO(), types.NamespacedName{
		Name:      in.Name,
		Namespace: in.Namespace}, out))

	verifyFernetSecret(t, in, out)
	verifyFernetRegen(t, in, out)
}

func TestRegenerateAllMultipleFernetFields(t *testing.T) {
	in := newFernetTestSecret("testfield,test1,test2", map[string]string{
		secret.AnnotationSecretRegenerate:      "yes",
		secret.AnnotationSecretAutoGeneratedAt: time.Now().Format(time.RFC3339),
	}, "test,abc,def")
	require.NoError(t, mgr.GetClient().Create(context.TODO(), in))

	doReconcile(t, in, false)

	out := &corev1.Secret{}
	require.NoError(t, mgr.GetClient().Get(context.TODO(), types.NamespacedName{
		Name:      in.Name,
		Namespace: in.Namespace}, out))

	verifyFernetSecret(t, in, out)
	verifyFernetRegen(t, in, out)
}

func TestFernetUniqueness(t *testing.T) {
	in := newFernetTestSecret("testfield,abc,test,abc,oops,oops", nil, "")
	require.NoError(t, mgr.GetClient().Create(context.TODO(), in))

	doReconcile(t, in, true)

	out := &corev1.Secret{}
	require.NoError(t, mgr.GetClient().Get(context.TODO(), types.NamespacedName{
		Name:      in.Name,
		Namespace: in.Namespace}, out))
}

func TestFernetTypeAnnotationDetected(t *testing.T) {
	in := newFernetTestSecret("testfield", map[string]string{
		secret.AnnotationSecretType: string(secret.TypeFernet),
	}, "")
	require.NoError(t, mgr.GetClient().Create(context.TODO(), in))

	doReconcile(t, in, false)

	out := &corev1.Secret{}
	require.NoError(t, mgr.GetClient().Get(context.TODO(), types.NamespacedName{
		Name:      in.Name,
		Namespace: in.Namespace}, out))
	verifyFernetSecret(t, in, out)
}

// Base64 encoded fernet key has a length of 44
func TestGeneratedFernetSecretHaveCorrectLength(t *testing.T) {
	key, err := secret.GenerateFernetKey()

	t.Log("generated", key)

	if err != nil {
		t.Error(err)
	}

	if len(key) != 44 {
		t.Error("string length", "expected", 44, "got", len(key))
	}
}

func TestGeneratedFernetSecretsAreRandom(t *testing.T) {
	one, errOne := secret.GenerateFernetKey()
	two, errTwo := secret.GenerateFernetKey()

	if errOne != nil {
		t.Error(errOne)
	}
	if errTwo != nil {
		t.Error(errTwo)
	}

	if string(one) == string(two) {
		t.Error("string equality", "got", one)
	}
}

func BenchmarkGenerateFernetSecret(b *testing.B) {
	for i := 0; i < b.N; i++ {
		_, err := secret.GenerateFernetKey()
		if err != nil {
			b.Error(err)
		}
	}
}
