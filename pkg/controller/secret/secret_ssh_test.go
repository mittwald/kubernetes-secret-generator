package secret_test

import (
	"bytes"
	"context"
	"github.com/go-logr/logr"
	"github.com/imdario/mergo"

	"github.com/stretchr/testify/require"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/types"
	"strconv"
	"testing"
	"time"

	"github.com/mittwald/kubernetes-secret-generator/pkg/controller/secret"
)

func newSSHKeypairTestSecret(t *testing.T, extraAnnotations map[string]string, initialized bool) *corev1.Secret {
	annotations := map[string]string{
		secret.AnnotationSecretType: string(secret.TypeSSHKeypair),
	}

	if extraAnnotations != nil {
		if err := mergo.Merge(&annotations, extraAnnotations, mergo.WithOverride); err != nil {
			panic(err)
		}
	}

	s := &corev1.Secret{
		ObjectMeta: metav1.ObjectMeta{
			Name:      getSecretName(),
			Namespace: "default",
			Labels: map[string]string{
				labelSecretGeneratorTest: "yes",
			},
			Annotations: annotations,
		},
		Type: corev1.SecretTypeOpaque,
		Data: map[string][]byte{},
	}

	var log logr.Logger

	if initialized {
		err := secret.GenerateSSHKeypairData(log, strconv.Itoa(secret.SSHKeyLength()), secret.DefaultSecretFieldPrivateKey, secret.DefaultSecretFieldPublicKey, true, s.Data)
		if err != nil {
			t.Error(err, "could not generate new ssh keypair")
		}

		s.Annotations[secret.AnnotationSecretAutoGeneratedAt] = time.Now().Format(time.RFC3339)
	}

	return s
}

func verifySSHKeypairSecret(t *testing.T, in, out *corev1.Secret) {
	if out.Annotations[secret.AnnotationSecretType] != string(secret.TypeSSHKeypair) {
		t.Errorf("generated secret has wrong type %s on  %s annotation", out.Annotations[secret.AnnotationSecretType], secret.AnnotationSecretType)
	}

	if _, ok := out.Annotations[secret.AnnotationSecretAutoGeneratedAt]; !ok {
		t.Errorf("secret has no %s annotation", secret.AnnotationSecretAutoGeneratedAt)
	}

	publicKey := out.Data[secret.DefaultSecretFieldPublicKey]
	privateKey := out.Data[secret.DefaultSecretFieldPrivateKey]

	if len(privateKey) == 0 || len(publicKey) == 0 {
		t.Errorf("publicKey(%d) or privateKey(%d) have invalid length", len(publicKey), len(privateKey))
	}

	key, err := secret.PrivateKeyFromPEM(privateKey)
	if err != nil {
		t.Error(err, "generated private key could not be parsed")
	}

	err = key.Validate()
	if err != nil {
		t.Error(err, "key validation failed")
	}

	pub, err := secret.SSHPublicKeyForPrivateKey(key)
	if err != nil {
		t.Error(err, "generated public key could not be parsed")
	}

	if !bytes.Equal(publicKey, pub) {
		t.Error("publicKey doesn't match private key")
	}
}

func verifySSHKeypairRegen(t *testing.T, in, out *corev1.Secret, regenDesired bool) {
	if _, ok := out.Annotations[secret.AnnotationSecretRegenerate]; ok {
		t.Errorf("%s annotation is still present", secret.AnnotationSecretRegenerate)
	}

	if _, ok := in.Annotations[secret.AnnotationSecretRegenerate]; !ok && regenDesired { // test the tester
		t.Errorf("%s annotation is not present on input", secret.AnnotationSecretRegenerate)
	}

	if _, ok := in.Annotations[secret.AnnotationSecretAutoGeneratedAt]; !ok { // test the tester
		t.Errorf("%s annotation is not present on input", secret.AnnotationSecretAutoGeneratedAt)
	}

	t.Logf("checking if keys have been regenerated")
	oldPublicKey := in.Data[secret.DefaultSecretFieldPublicKey]
	oldPrivateKey := in.Data[secret.DefaultSecretFieldPrivateKey]

	newPublicKey := out.Data[secret.DefaultSecretFieldPublicKey]
	newPrivateKey := out.Data[secret.DefaultSecretFieldPrivateKey]

	equal := bytes.Equal(oldPublicKey, newPublicKey)
	if equal && regenDesired {
		t.Error("publicKey has not been regenerated")
	} else if !equal && !regenDesired {
		t.Error("publicKey has been regenerated")
	}

	equal = bytes.Equal(oldPrivateKey, newPrivateKey)
	if equal && regenDesired {
		t.Error("privateKey has not been regenerated")
	} else if !equal && !regenDesired {
		t.Error("privateKey has been regenerated")
	}
}

func TestSSHKeypairIsGenerated(t *testing.T) {
	in := newSSHKeypairTestSecret(t, nil, false)
	require.NoError(t, mgr.GetClient().Create(context.TODO(), in))

	doReconcile(t, in, false)

	out := &corev1.Secret{}
	require.NoError(t, mgr.GetClient().Get(context.TODO(), types.NamespacedName{
		Name:      in.Name,
		Namespace: in.Namespace}, out))
	verifySSHKeypairSecret(t, in, out)
}

func TestSSHKeypairIsNotRegenerated(t *testing.T) {
	in := newSSHKeypairTestSecret(t, nil, true)
	require.NoError(t, mgr.GetClient().Create(context.TODO(), in))

	doReconcile(t, in, false)

	out := &corev1.Secret{}
	require.NoError(t, mgr.GetClient().Get(context.TODO(), types.NamespacedName{
		Name:      in.Name,
		Namespace: in.Namespace}, out))
	verifySSHKeypairSecret(t, in, out)
	verifySSHKeypairRegen(t, in, out, false)
}

func TestSSHKeypairIsRegenerated(t *testing.T) {
	in := newSSHKeypairTestSecret(t, map[string]string{
		secret.AnnotationSecretRegenerate: "true",
	}, true)
	require.NoError(t, mgr.GetClient().Create(context.TODO(), in))

	doReconcile(t, in, false)

	out := &corev1.Secret{}
	require.NoError(t, mgr.GetClient().Get(context.TODO(), types.NamespacedName{
		Name:      in.Name,
		Namespace: in.Namespace}, out))
	verifySSHKeypairSecret(t, in, out)
	verifySSHKeypairRegen(t, in, out, true)
}

func TestSSHKeypairLengthAnnotation(t *testing.T) {
	in := newSSHKeypairTestSecret(t, map[string]string{
		secret.AnnotationSecretRegenerate: "true",
		secret.AnnotationSecretLength:     "4096",
	}, true)
	require.NoError(t, mgr.GetClient().Create(context.TODO(), in))

	doReconcile(t, in, false)

	out := &corev1.Secret{}
	require.NoError(t, mgr.GetClient().Get(context.TODO(), types.NamespacedName{
		Name:      in.Name,
		Namespace: in.Namespace}, out))
	verifySSHKeypairSecret(t, in, out)

	key, err := secret.PrivateKeyFromPEM(out.Data[secret.DefaultSecretFieldPrivateKey])
	if err != nil {
		t.Error(err, "generated private key could not be parsed")
	}

	// Size() returns size in bytes
	if key.Size()*8 != 4096 {
		t.Error(err, "wrong generated secret length")
	}
}

func TestSSHKeypairKeyFieldAnnotations(t *testing.T) {
	in := newSSHKeypairTestSecret(t, map[string]string{
		secret.AnnotationSSHPrivateKeyField: "sshPrivateKey",
		secret.AnnotationSSHPublicKeyField:  "sshPublicKey",
	}, true)
	require.NoError(t, mgr.GetClient().Create(context.TODO(), in))

	doReconcile(t, in, false)

	out := &corev1.Secret{}
	require.NoError(t, mgr.GetClient().Get(context.TODO(), types.NamespacedName{
		Name:      in.Name,
		Namespace: in.Namespace}, out))
	verifySSHKeypairSecret(t, in, out)

	privateKey, ok := out.Data["sshPrivateKey"]
	if !ok {
		t.Error("sshPrivateKey not in data")
	}

	publicKey, ok := out.Data["sshPublicKey"]
	if !ok {
		t.Error("sshPublicKey not in data")
	}

	key, err := secret.PrivateKeyFromPEM(privateKey)
	if err != nil {
		t.Error(err, "generated private key could not be parsed")
	}

	pub, err := secret.SSHPublicKeyForPrivateKey(key)
	if err != nil {
		t.Error(err, "generated public key could not be parsed")
	}

	if !bytes.Equal(publicKey, pub) {
		t.Error("publicKey doesn't match private key")
	}
}

func TestSSHKeypairLengthDefault(t *testing.T) {
	in := newSSHKeypairTestSecret(t, map[string]string{
		secret.AnnotationSecretRegenerate: "true",
	}, true)
	require.NoError(t, mgr.GetClient().Create(context.TODO(), in))

	doReconcile(t, in, false)

	out := &corev1.Secret{}
	require.NoError(t, mgr.GetClient().Get(context.TODO(), types.NamespacedName{
		Name:      in.Name,
		Namespace: in.Namespace}, out))
	verifySSHKeypairSecret(t, in, out)

	key, err := secret.PrivateKeyFromPEM(out.Data[secret.DefaultSecretFieldPrivateKey])
	if err != nil {
		t.Error(err, "generated private key could not be parsed")
	}

	// Size() returns size in bytes
	if key.Size()*8 != 2048 {
		t.Error("wrong generated secret length")
	}
}
